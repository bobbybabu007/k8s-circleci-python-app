## Sample Python app for CircleCI Demo

Our [Sample Python Application](.app.py) runs a Welcome function
The tester application runs a Tester function that checks integrity of Add() within the App/src [CircleCI pipeline config](.circleci/config.yaml) 

## Realise a CircleCI Self Hosted Runner on your K8s cluster

#### Checks and Pre-requisites

1. Working Kubernetes cluster with appropriate RBAC privileges.

2. Determine reqs(if any) for a custom Docker image for the CircleCI runner.

3. Determine secret creation to be done manually(beforehand such as imagePullSecrets) or by helm.

4. Determine Service Account to use, else helm will create "circleci-runner"

5. Determine nodeSelectors, tolerations or affinity [where and how should the runner pods be])


#### Steps

1. Sign in to the CircleCI platform and choose the project that needs a self hosted runner.

2. Create a CircleCI self-hosted runner resource class.

    > Resourceclass name : <b>myns/rc-circlci</b>

    > Auth token (Generated)         : <b>xxxxxxxxxxxxxxxxd28d6926xxxxxxxx9fa407591xxxxxxxxxxxx</b>
```bash
Note: 
* Each resource class requires a unique token to configure your self-hosted runners during the installation process.
* If you have already created a resource class, use the token that was given to you; 
* If you are creating a resource class now, keep the token generated by your CircleCI safe for future use.
```

3. Clone the [CircleCI Runner for k8s repository](https://github.com/CircleCI-Public/circleci-runner-k8s) that contains the helm chart.

```bash
git clone https://github.com/CircleCI-Public/circleci-runner-k8s
cd circleci-runner-k8s && ls
```

4. Inspect the chart [templates and values] and modify the values.yaml as needed.

5. Define Environment Variables to configure the runner from [ConfigPage](https://circleci.com/docs/runner-config-reference), such as to add additional Kubernetes secret references

```bash
env:
  - name: MYTEAM
    value: "PRAGRA"
  - name: SECRET_ENV
    valueFrom:
      secretKeyRef:
        key: secret1
        name: runner-secrets
```


6. Login to your k8s cluster and export the resource class name and token

```bash
export CIRCLECI_RUNNER_TOKEN="xxxxxxxxxxxxxxxxd28d6926xxxxxxxx9fa407591xxxxxxxxxxxx"
export CIRCLECI_RUNNER_RESOURCE_CLASS="myns/rc-circlci"
```


7. Create the Namespace "myns" and secret "runner-secrets" before running helm install

```bash
kubectl create ns myns

kubectl create secret generic runner-secrets \
  --namespace myns \
  --from-literal secret1=secret1value

kubectl -n myns edit secret runner-secrets 

#Below is to confirm the base64 secret encoding
echo secret1value | base64
>> c2VjcmV0MXZhbHVlCg==
echo c2VjcmV0MXZhbHVlCg== | base64 --decode
>> secret1value
```


8. Install a runner release using the chart

```bash
helm install "circleci-runner" ./ \
  --set runnerToken=$CIRCLECI_RUNNER_TOKEN \
  --set resourceClass=$CIRCLECI_RUNNER_RESOURCE_CLASS \
  --namespace myns
```


9. Verify pod and its logs

```bash
kubectl -n myns get pods 

kubectl -n myns logs -f circleci-runner-7d2f64jh86f-4f7yl

>>    time="2021-03-25T20:55:40Z" level=info msg="CircleCI launcher starting" config=/var/opt/circleci/launch-agent-config.yaml
>>    time="2021-03-25T20:55:40Z" level=info msg="loaded config" name=circleci-runner-test-7d6b8fc6f-4z5wl url="https://runner.circleci.com"
>>    time="2021-03-25T20:55:40Z" level=info msg="no task found"
```


#### Realise the CI/CD for a CircleCI pipeline using Self-Hosted Runners in your k8s cluster.

â€‹CircleCI should detect the code changes and run our build_and_test workflow for our branch. 
We should be able to see the jobs run on CircleCI's website.


<b> Testing CI with Good Code </b>

1. Create a feature branch

```bash
git checkout -b feat/goodcode
```

2. Update/Replace Tester() in app-tester.py with below line

```bash
assert Add(5,5) == 10
```

3. Git Commit & Push to remote

```bash
git branch
git status
git commit -am "update app-tester with new parameters"
git push --set-upstream origin feat/goodcode
```

4. Go to GitHub and realise a Pull Request for this branch to see if CircleCI is running our jobs in our k8s cluster. 

```bash
watch kubectl -n myns get pods
```

We should see a build job and a test job with green checkmarks since app build and app tests pass. This means our CI is working. 


<b> Testing CI with Bad Code </b>

1. Create a feature branch 

```bash
git checkout -b feat/badcode
```

2. Update the sourcecode (app.py) by making the addition inside the Add() do a multiplication instead. This would mess up the application code which should be caught by the tester function, being executed within the app-tester.py

3. Commit & Push the code into remote
```bash
git add .
git commit -am "update code with multiplier,remove addition"
git push --set-upstream origin feat/badcode
```

4. Go to GitHub and realise a Pull Request for this branch to see if CircleCI is running our jobs in our k8s cluster. 

```bash
watch kubectl -n myns get pods
```

5. We should see the build step is successful as the source code is still functional. But our test step fails since 2 * 3 isn't 5. 
Our team can now realise that the incoming source code change from branch feat/badcode is harmful; They shouldn't merge this PR

Key: CircleCI can use this failed test job from its workflow to stop downstream jobs from happening (No deployment of bad code.

#### Source & Credits: 

1. [srcmake/CircleCI Demo](https://www.srcmake.com/home/circleci)

2. [srcmake/CircleCI GitHub](https://github.com/srcmake/circleci-demo)

3. [CircleCI Self-hosted Runner Installation on Kubernetes](https://circleci.com/docs/runner-on-kubernetes)